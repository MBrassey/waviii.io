{"ast":null,"code":"\"use strict\";\n/**\n *  Conversion Utilities\n *\n */\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar errors = __importStar(require(\"../errors\")); ///////////////////////////////\n\n\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\n\nexports.isHexable = isHexable;\n\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n\n  return array;\n}\n\nfunction isArrayish(value) {\n  if (!value || parseInt(String(value.length)) != value.length || typeof value === 'string') {\n    return false;\n  }\n\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n\n    if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isArrayish = isArrayish;\n\nfunction arrayify(value) {\n  if (value == null) {\n    errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n\n  if (typeof value === 'string') {\n    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    if (match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    value = value.substring(2);\n\n    if (value.length % 2) {\n      value = '0' + value;\n    }\n\n    var result = [];\n\n    for (var i = 0; i < value.length; i += 2) {\n      result.push(parseInt(value.substr(i, 2), 16));\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (isArrayish(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  errors.throwError('invalid arrayify value', null, {\n    arg: 'value',\n    value: value,\n    type: typeof value\n  });\n  return null;\n}\n\nexports.arrayify = arrayify;\n\nfunction concat(objects) {\n  var arrays = [];\n  var length = 0;\n\n  for (var i = 0; i < objects.length; i++) {\n    var object = arrayify(objects[i]);\n    arrays.push(object);\n    length += object.length;\n  }\n\n  var result = new Uint8Array(length);\n  var offset = 0;\n\n  for (var i = 0; i < arrays.length; i++) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n\n  return addSlice(result);\n}\n\nexports.concat = concat;\n\nfunction stripZeros(value) {\n  var result = arrayify(value);\n\n  if (result.length === 0) {\n    return result;\n  } // Find the first non-zero entry\n\n\n  var start = 0;\n\n  while (result[start] === 0) {\n    start++;\n  } // If we started with zeros, strip them\n\n\n  if (start) {\n    result = result.slice(start);\n  }\n\n  return result;\n}\n\nexports.stripZeros = stripZeros;\n\nfunction padZeros(value, length) {\n  value = arrayify(value);\n\n  if (length < value.length) {\n    throw new Error('cannot pad');\n  }\n\n  var result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\n\nexports.padZeros = padZeros;\n\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isHexString = isHexString;\nvar HexCharacters = '0123456789abcdef';\n\nfunction hexlify(value) {\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n\n  if (typeof value === 'number') {\n    if (value < 0) {\n      errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    } // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n    // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n\n\n    if (value >= 9007199254740991) {\n      errors.throwError(\"out-of-range\", errors.NUMERIC_FAULT, {\n        operartion: \"hexlify\",\n        fault: \"out-of-safe-range\"\n      });\n    }\n\n    var hex = '';\n\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = Math.floor(value / 16);\n    }\n\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = '0' + hex;\n      }\n\n      return '0x' + hex;\n    }\n\n    return '0x00';\n  }\n\n  if (typeof value === 'string') {\n    var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n    if (!match) {\n      errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    if (match[1] !== '0x') {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    if (value.length % 2) {\n      value = '0x0' + value.substring(2);\n    }\n\n    return value;\n  }\n\n  if (isArrayish(value)) {\n    var result = [];\n\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n    }\n\n    return '0x' + result.join('');\n  }\n\n  errors.throwError('invalid hexlify value', null, {\n    arg: 'value',\n    value: value\n  });\n  return 'never';\n}\n\nexports.hexlify = hexlify;\n\nfunction hexDataLength(data) {\n  if (!isHexString(data) || data.length % 2 !== 0) {\n    return null;\n  }\n\n  return (data.length - 2) / 2;\n}\n\nexports.hexDataLength = hexDataLength;\n\nfunction hexDataSlice(data, offset, endOffset) {\n  if (!isHexString(data)) {\n    errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data\n    });\n  }\n\n  if (data.length % 2 !== 0) {\n    errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: data\n    });\n  }\n\n  offset = 2 + 2 * offset;\n\n  if (endOffset != null) {\n    return '0x' + data.substring(offset, 2 + 2 * endOffset);\n  }\n\n  return '0x' + data.substring(offset);\n}\n\nexports.hexDataSlice = hexDataSlice;\n\nfunction hexStripZeros(value) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  while (value.length > 3 && value.substring(0, 3) === '0x0') {\n    value = '0x' + value.substring(3);\n  }\n\n  return value;\n}\n\nexports.hexStripZeros = hexStripZeros;\n\nfunction hexZeroPad(value, length) {\n  if (!isHexString(value)) {\n    errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  while (value.length < 2 * length + 2) {\n    value = '0x0' + value.substring(2);\n  }\n\n  return value;\n}\n\nexports.hexZeroPad = hexZeroPad;\n\nfunction isSignature(value) {\n  return value && value.r != null && value.s != null;\n}\n\nfunction splitSignature(signature) {\n  var v = 0;\n  var r = '0x',\n      s = '0x';\n\n  if (isSignature(signature)) {\n    if (signature.v == null && signature.recoveryParam == null) {\n      errors.throwError('at least on of recoveryParam or v must be specified', errors.INVALID_ARGUMENT, {\n        argument: 'signature',\n        value: signature\n      });\n    }\n\n    r = hexZeroPad(signature.r, 32);\n    s = hexZeroPad(signature.s, 32);\n    v = signature.v;\n\n    if (typeof v === 'string') {\n      v = parseInt(v, 16);\n    }\n\n    var recoveryParam = signature.recoveryParam;\n\n    if (recoveryParam == null && signature.v != null) {\n      recoveryParam = 1 - v % 2;\n    }\n\n    v = 27 + recoveryParam;\n  } else {\n    var bytes = arrayify(signature);\n\n    if (bytes.length !== 65) {\n      throw new Error('invalid signature');\n    }\n\n    r = hexlify(bytes.slice(0, 32));\n    s = hexlify(bytes.slice(32, 64));\n    v = bytes[64];\n\n    if (v !== 27 && v !== 28) {\n      v = 27 + v % 2;\n    }\n  }\n\n  return {\n    r: r,\n    s: s,\n    recoveryParam: v - 27,\n    v: v\n  };\n}\n\nexports.splitSignature = splitSignature;\n\nfunction joinSignature(signature) {\n  signature = splitSignature(signature);\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? '0x1c' : '0x1b']));\n}\n\nexports.joinSignature = joinSignature;","map":{"version":3,"sources":["/home/luc1d/Code/Github/waviii.io/node_modules/ethers/utils/bytes.js"],"names":["__importStar","mod","__esModule","result","k","Object","hasOwnProperty","call","defineProperty","exports","value","errors","require","isHexable","toHexString","addSlice","array","slice","args","Array","prototype","arguments","Uint8Array","apply","isArrayish","parseInt","String","length","i","v","arrayify","throwError","INVALID_ARGUMENT","arg","match","substring","push","substr","type","concat","objects","arrays","object","offset","set","stripZeros","start","padZeros","Error","isHexString","HexCharacters","hexlify","NUMERIC_FAULT","operartion","fault","hex","Math","floor","join","hexDataLength","data","hexDataSlice","endOffset","hexStripZeros","hexZeroPad","isSignature","r","s","splitSignature","signature","recoveryParam","argument","bytes","joinSignature"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n *  Conversion Utilities\n *\n */\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar errors = __importStar(require(\"../errors\"));\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nexports.isHexable = isHexable;\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        var args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isArrayish(value) {\n    if (!value || parseInt(String(value.length)) != value.length || typeof (value) === 'string') {\n        return false;\n    }\n    for (var i = 0; i < value.length; i++) {\n        var v = value[i];\n        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayish = isArrayish;\nfunction arrayify(value) {\n    if (value == null) {\n        errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (typeof (value) === 'string') {\n        var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        if (match[1] !== '0x') {\n            errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        value = value.substring(2);\n        if (value.length % 2) {\n            value = '0' + value;\n        }\n        var result = [];\n        for (var i = 0; i < value.length; i += 2) {\n            result.push(parseInt(value.substr(i, 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isArrayish(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    errors.throwError('invalid arrayify value', null, { arg: 'value', value: value, type: typeof (value) });\n    return null;\n}\nexports.arrayify = arrayify;\nfunction concat(objects) {\n    var arrays = [];\n    var length = 0;\n    for (var i = 0; i < objects.length; i++) {\n        var object = arrayify(objects[i]);\n        arrays.push(object);\n        length += object.length;\n    }\n    var result = new Uint8Array(length);\n    var offset = 0;\n    for (var i = 0; i < arrays.length; i++) {\n        result.set(arrays[i], offset);\n        offset += arrays[i].length;\n    }\n    return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n    var result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    var start = 0;\n    while (result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexports.stripZeros = stripZeros;\nfunction padZeros(value, length) {\n    value = arrayify(value);\n    if (length < value.length) {\n        throw new Error('cannot pad');\n    }\n    var result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nexports.padZeros = padZeros;\nfunction isHexString(value, length) {\n    if (typeof (value) !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = '0123456789abcdef';\nfunction hexlify(value) {\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (typeof (value) === 'number') {\n        if (value < 0) {\n            errors.throwError('cannot hexlify negative value', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        // @TODO: Roll this into the above error as a numeric fault (overflow); next version, not backward compatible\n        // We can about (value == MAX_INT) to as well, since that may indicate we underflowed already\n        if (value >= 9007199254740991) {\n            errors.throwError(\"out-of-range\", errors.NUMERIC_FAULT, {\n                operartion: \"hexlify\",\n                fault: \"out-of-safe-range\"\n            });\n        }\n        var hex = '';\n        while (value) {\n            hex = HexCharacters[value & 0x0f] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = '0' + hex;\n            }\n            return '0x' + hex;\n        }\n        return '0x00';\n    }\n    if (typeof (value) === 'string') {\n        var match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        if (match[1] !== '0x') {\n            errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n        }\n        if (value.length % 2) {\n            value = '0x0' + value.substring(2);\n        }\n        return value;\n    }\n    if (isArrayish(value)) {\n        var result = [];\n        for (var i = 0; i < value.length; i++) {\n            var v = value[i];\n            result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n        }\n        return '0x' + result.join('');\n    }\n    errors.throwError('invalid hexlify value', null, { arg: 'value', value: value });\n    return 'never';\n}\nexports.hexlify = hexlify;\nfunction hexDataLength(data) {\n    if (!isHexString(data) || (data.length % 2) !== 0) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n    if (!isHexString(data)) {\n        errors.throwError('invalid hex data', errors.INVALID_ARGUMENT, { arg: 'value', value: data });\n    }\n    if ((data.length % 2) !== 0) {\n        errors.throwError('hex data length must be even', errors.INVALID_ARGUMENT, { arg: 'value', value: data });\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return '0x' + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return '0x' + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexStripZeros(value) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n    }\n    while (value.length > 3 && value.substring(0, 3) === '0x0') {\n        value = '0x' + value.substring(3);\n    }\n    return value;\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n    if (!isHexString(value)) {\n        errors.throwError('invalid hex string', errors.INVALID_ARGUMENT, { arg: 'value', value: value });\n    }\n    while (value.length < 2 * length + 2) {\n        value = '0x0' + value.substring(2);\n    }\n    return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction isSignature(value) {\n    return (value && value.r != null && value.s != null);\n}\nfunction splitSignature(signature) {\n    var v = 0;\n    var r = '0x', s = '0x';\n    if (isSignature(signature)) {\n        if (signature.v == null && signature.recoveryParam == null) {\n            errors.throwError('at least on of recoveryParam or v must be specified', errors.INVALID_ARGUMENT, { argument: 'signature', value: signature });\n        }\n        r = hexZeroPad(signature.r, 32);\n        s = hexZeroPad(signature.s, 32);\n        v = signature.v;\n        if (typeof (v) === 'string') {\n            v = parseInt(v, 16);\n        }\n        var recoveryParam = signature.recoveryParam;\n        if (recoveryParam == null && signature.v != null) {\n            recoveryParam = 1 - (v % 2);\n        }\n        v = 27 + recoveryParam;\n    }\n    else {\n        var bytes = arrayify(signature);\n        if (bytes.length !== 65) {\n            throw new Error('invalid signature');\n        }\n        r = hexlify(bytes.slice(0, 32));\n        s = hexlify(bytes.slice(32, 64));\n        v = bytes[64];\n        if (v !== 27 && v !== 28) {\n            v = 27 + (v % 2);\n        }\n    }\n    return {\n        r: r,\n        s: s,\n        recoveryParam: (v - 27),\n        v: v\n    };\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? '0x1c' : '0x1b')\n    ]));\n}\nexports.joinSignature = joinSignature;\n"]},"metadata":{},"sourceType":"script"}