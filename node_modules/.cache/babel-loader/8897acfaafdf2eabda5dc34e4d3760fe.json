{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar Transform = require('stream').Transform;\n\nvar inherits = require('inherits');\n\nmodule.exports = function (KeccakState) {\n  function Keccak(rate, capacity, delimitedSuffix, hashBitLength, options) {\n    Transform.call(this, options);\n    this._rate = rate;\n    this._capacity = capacity;\n    this._delimitedSuffix = delimitedSuffix;\n    this._hashBitLength = hashBitLength;\n    this._options = options;\n    this._state = new KeccakState();\n\n    this._state.initialize(rate, capacity);\n\n    this._finalized = false;\n  }\n\n  inherits(Keccak, Transform);\n\n  Keccak.prototype._transform = function (chunk, encoding, callback) {\n    var error = null;\n\n    try {\n      this.update(chunk, encoding);\n    } catch (err) {\n      error = err;\n    }\n\n    callback(error);\n  };\n\n  Keccak.prototype._flush = function (callback) {\n    var error = null;\n\n    try {\n      this.push(this.digest());\n    } catch (err) {\n      error = err;\n    }\n\n    callback(error);\n  };\n\n  Keccak.prototype.update = function (data, encoding) {\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');\n    if (this._finalized) throw new Error('Digest already called');\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);\n\n    this._state.absorb(data);\n\n    return this;\n  };\n\n  Keccak.prototype.digest = function (encoding) {\n    if (this._finalized) throw new Error('Digest already called');\n    this._finalized = true;\n    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix);\n\n    var digest = this._state.squeeze(this._hashBitLength / 8);\n\n    if (encoding !== undefined) digest = digest.toString(encoding);\n\n    this._resetState();\n\n    return digest;\n  }; // remove result from memory\n\n\n  Keccak.prototype._resetState = function () {\n    this._state.initialize(this._rate, this._capacity);\n\n    return this;\n  }; // because sometimes we need hash right now and little later\n\n\n  Keccak.prototype._clone = function () {\n    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);\n\n    this._state.copy(clone._state);\n\n    clone._finalized = this._finalized;\n    return clone;\n  };\n\n  return Keccak;\n};","map":{"version":3,"sources":["/home/luc1d/Code/Github/waviii.io/node_modules/keccak/lib/api/keccak.js"],"names":["Buffer","require","Transform","inherits","module","exports","KeccakState","Keccak","rate","capacity","delimitedSuffix","hashBitLength","options","call","_rate","_capacity","_delimitedSuffix","_hashBitLength","_options","_state","initialize","_finalized","prototype","_transform","chunk","encoding","callback","error","update","err","_flush","push","digest","data","isBuffer","TypeError","Error","from","absorb","absorbLastFewBits","squeeze","undefined","toString","_resetState","_clone","clone","copy"],"mappings":"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","sourcesContent":["'use strict'\nvar Buffer = require('safe-buffer').Buffer\nvar Transform = require('stream').Transform\nvar inherits = require('inherits')\n\nmodule.exports = function (KeccakState) {\n  function Keccak (rate, capacity, delimitedSuffix, hashBitLength, options) {\n    Transform.call(this, options)\n\n    this._rate = rate\n    this._capacity = capacity\n    this._delimitedSuffix = delimitedSuffix\n    this._hashBitLength = hashBitLength\n    this._options = options\n\n    this._state = new KeccakState()\n    this._state.initialize(rate, capacity)\n    this._finalized = false\n  }\n\n  inherits(Keccak, Transform)\n\n  Keccak.prototype._transform = function (chunk, encoding, callback) {\n    var error = null\n    try {\n      this.update(chunk, encoding)\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  Keccak.prototype._flush = function (callback) {\n    var error = null\n    try {\n      this.push(this.digest())\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  Keccak.prototype.update = function (data, encoding) {\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\n    if (this._finalized) throw new Error('Digest already called')\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n    this._state.absorb(data)\n\n    return this\n  }\n\n  Keccak.prototype.digest = function (encoding) {\n    if (this._finalized) throw new Error('Digest already called')\n    this._finalized = true\n\n    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)\n    var digest = this._state.squeeze(this._hashBitLength / 8)\n    if (encoding !== undefined) digest = digest.toString(encoding)\n\n    this._resetState()\n\n    return digest\n  }\n\n  // remove result from memory\n  Keccak.prototype._resetState = function () {\n    this._state.initialize(this._rate, this._capacity)\n    return this\n  }\n\n  // because sometimes we need hash right now and little later\n  Keccak.prototype._clone = function () {\n    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)\n    this._state.copy(clone._state)\n    clone._finalized = this._finalized\n\n    return clone\n  }\n\n  return Keccak\n}\n"]},"metadata":{},"sourceType":"script"}