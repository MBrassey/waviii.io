{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar bytes_1 = require(\"./bytes\"); ///////////////////////////////\n\n\nvar UnicodeNormalizationForm;\n\n(function (UnicodeNormalizationForm) {\n  UnicodeNormalizationForm[\"current\"] = \"\";\n  UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n  UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n  UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n  UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n\n; // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n\nfunction toUtf8Bytes(str, form) {\n  if (form === void 0) {\n    form = UnicodeNormalizationForm.current;\n  }\n\n  if (form != UnicodeNormalizationForm.current) {\n    errors_1.checkNormalize();\n    str = str.normalize(form);\n  }\n\n  var result = [];\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push(c >> 6 | 0xc0);\n      result.push(c & 0x3f | 0x80);\n    } else if ((c & 0xfc00) == 0xd800) {\n      i++;\n      var c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new Error('invalid utf-8 string');\n      } // Surrogate Pair\n\n\n      c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push(c >> 18 | 0xf0);\n      result.push(c >> 12 & 0x3f | 0x80);\n      result.push(c >> 6 & 0x3f | 0x80);\n      result.push(c & 0x3f | 0x80);\n    } else {\n      result.push(c >> 12 | 0xe0);\n      result.push(c >> 6 & 0x3f | 0x80);\n      result.push(c & 0x3f | 0x80);\n    }\n  }\n\n  return bytes_1.arrayify(result);\n}\n\nexports.toUtf8Bytes = toUtf8Bytes;\n; // http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n\nfunction toUtf8String(bytes, ignoreErrors) {\n  bytes = bytes_1.arrayify(bytes);\n  var result = '';\n  var i = 0; // Invalid bytes are ignored\n\n  while (i < bytes.length) {\n    var c = bytes[i++]; // 0xxx xxxx\n\n    if (c >> 7 === 0) {\n      result += String.fromCharCode(c);\n      continue;\n    } // Multibyte; how many bytes left for this character?\n\n\n    var extraLength = null;\n    var overlongMask = null; // 110x xxxx 10xx xxxx\n\n    if ((c & 0xe0) === 0xc0) {\n      extraLength = 1;\n      overlongMask = 0x7f; // 1110 xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf0) === 0xe0) {\n      extraLength = 2;\n      overlongMask = 0x7ff; // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n    } else if ((c & 0xf8) === 0xf0) {\n      extraLength = 3;\n      overlongMask = 0xffff;\n    } else {\n      if (!ignoreErrors) {\n        if ((c & 0xc0) === 0x80) {\n          throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n        }\n\n        throw new Error('invalid utf8 byte sequence; invalid prefix');\n      }\n\n      continue;\n    } // Do we have enough bytes in our data?\n\n\n    if (i + extraLength > bytes.length) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; too short');\n      } // If there is an invalid unprocessed byte, skip continuation bytes\n\n\n      for (; i < bytes.length; i++) {\n        if (bytes[i] >> 6 !== 0x02) {\n          break;\n        }\n      }\n\n      continue;\n    } // Remove the length prefix from the char\n\n\n    var res = c & (1 << 8 - extraLength - 1) - 1;\n\n    for (var j = 0; j < extraLength; j++) {\n      var nextChar = bytes[i]; // Invalid continuation byte\n\n      if ((nextChar & 0xc0) != 0x80) {\n        res = null;\n        break;\n      }\n\n      ;\n      res = res << 6 | nextChar & 0x3f;\n      i++;\n    }\n\n    if (res === null) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n      }\n\n      continue;\n    } // Check for overlong seuences (more bytes than needed)\n\n\n    if (res <= overlongMask) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; overlong');\n      }\n\n      continue;\n    } // Maximum code point\n\n\n    if (res > 0x10ffff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; out-of-range');\n      }\n\n      continue;\n    } // Reserved for UTF-16 surrogate halves\n\n\n    if (res >= 0xd800 && res <= 0xdfff) {\n      if (!ignoreErrors) {\n        throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n      }\n\n      continue;\n    }\n\n    if (res <= 0xffff) {\n      result += String.fromCharCode(res);\n      continue;\n    }\n\n    res -= 0x10000;\n    result += String.fromCharCode((res >> 10 & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n  }\n\n  return result;\n}\n\nexports.toUtf8String = toUtf8String;\n\nfunction formatBytes32String(text) {\n  // Get the bytes\n  var bytes = toUtf8Bytes(text); // Check we have room for null-termination\n\n  if (bytes.length > 31) {\n    throw new Error('bytes32 string must be less than 32 bytes');\n  } // Zero-pad (implicitly null-terminates)\n\n\n  return bytes_1.hexlify(bytes_1.concat([bytes, constants_1.HashZero]).slice(0, 32));\n}\n\nexports.formatBytes32String = formatBytes32String;\n\nfunction parseBytes32String(bytes) {\n  var data = bytes_1.arrayify(bytes); // Must be 32 bytes with a null-termination\n\n  if (data.length !== 32) {\n    throw new Error('invalid bytes32 - not 32 bytes long');\n  }\n\n  if (data[31] !== 0) {\n    throw new Error('invalid bytes32 string - no null terminator');\n  } // Find the null termination\n\n\n  var length = 31;\n\n  while (data[length - 1] === 0) {\n    length--;\n  } // Determine the string value\n\n\n  return toUtf8String(data.slice(0, length));\n}\n\nexports.parseBytes32String = parseBytes32String;","map":{"version":3,"sources":["/home/luc1d/Code/Github/waviii.io/node_modules/ethers/utils/utf8.js"],"names":["Object","defineProperty","exports","value","constants_1","require","errors_1","bytes_1","UnicodeNormalizationForm","toUtf8Bytes","str","form","current","checkNormalize","normalize","result","i","length","c","charCodeAt","push","c2","Error","arrayify","toUtf8String","bytes","ignoreErrors","String","fromCharCode","extraLength","overlongMask","res","j","nextChar","formatBytes32String","text","hexlify","concat","HashZero","slice","parseBytes32String","data"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar bytes_1 = require(\"./bytes\");\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n;\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form) {\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n    if (form != UnicodeNormalizationForm.current) {\n        errors_1.checkNormalize();\n        str = str.normalize(form);\n    }\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            var c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error('invalid utf-8 string');\n            }\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((c >> 18) | 0xf0);\n            result.push(((c >> 12) & 0x3f) | 0x80);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return bytes_1.arrayify(result);\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n;\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction toUtf8String(bytes, ignoreErrors) {\n    bytes = bytes_1.arrayify(bytes);\n    var result = '';\n    var i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        var c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result += String.fromCharCode(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        var extraLength = null;\n        var overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if (!ignoreErrors) {\n                if ((c & 0xc0) === 0x80) {\n                    throw new Error('invalid utf8 byte sequence; unexpected continuation byte');\n                }\n                throw new Error('invalid utf8 byte sequence; invalid prefix');\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i + extraLength > bytes.length) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; too short');\n            }\n            // If there is an invalid unprocessed byte, skip continuation bytes\n            for (; i < bytes.length; i++) {\n                if (bytes[i] >> 6 !== 0x02) {\n                    break;\n                }\n            }\n            continue;\n        }\n        // Remove the length prefix from the char\n        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (var j = 0; j < extraLength; j++) {\n            var nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        if (res === null) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; invalid continuation byte');\n            }\n            continue;\n        }\n        // Check for overlong seuences (more bytes than needed)\n        if (res <= overlongMask) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; overlong');\n            }\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; out-of-range');\n            }\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            if (!ignoreErrors) {\n                throw new Error('invalid utf8 byte sequence; utf-16 surrogate');\n            }\n            continue;\n        }\n        if (res <= 0xffff) {\n            result += String.fromCharCode(res);\n            continue;\n        }\n        res -= 0x10000;\n        result += String.fromCharCode(((res >> 10) & 0x3ff) + 0xd800, (res & 0x3ff) + 0xdc00);\n    }\n    return result;\n}\nexports.toUtf8String = toUtf8String;\nfunction formatBytes32String(text) {\n    // Get the bytes\n    var bytes = toUtf8Bytes(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error('bytes32 string must be less than 32 bytes');\n    }\n    // Zero-pad (implicitly null-terminates)\n    return bytes_1.hexlify(bytes_1.concat([bytes, constants_1.HashZero]).slice(0, 32));\n}\nexports.formatBytes32String = formatBytes32String;\nfunction parseBytes32String(bytes) {\n    var data = bytes_1.arrayify(bytes);\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error('invalid bytes32 - not 32 bytes long');\n    }\n    if (data[31] !== 0) {\n        throw new Error('invalid bytes32 string - no null terminator');\n    }\n    // Find the null termination\n    var length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return toUtf8String(data.slice(0, length));\n}\nexports.parseBytes32String = parseBytes32String;\n"]},"metadata":{},"sourceType":"script"}