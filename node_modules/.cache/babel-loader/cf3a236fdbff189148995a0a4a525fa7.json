{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nvar constants_1 = require(\"../constants\");\n\nvar errors = __importStar(require(\"../errors\"));\n\nvar address_1 = require(\"./address\");\n\nvar bignumber_1 = require(\"./bignumber\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar utf8_1 = require(\"./utf8\");\n\nvar properties_1 = require(\"./properties\"); ///////////////////////////////\n\n\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexports.defaultCoerceFunc = function (type, value) {\n  var match = type.match(paramTypeNumber);\n\n  if (match && parseInt(match[2]) <= 48) {\n    return value.toNumber();\n  }\n\n  return value;\n}; ///////////////////////////////////\n// Parsing for Solidity Signatures\n\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n\n  return type;\n}\n\nfunction parseParam(param, allowIndexed) {\n  var originalParam = param;\n\n  function throwError(i) {\n    throw new Error('unexpected character \"' + originalParam[i] + '\" at position ' + i + ' in \"' + originalParam + '\"');\n  }\n\n  param = param.replace(/\\s/g, ' ');\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case '(':\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case ',':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        node.type = verifyType(node.type);\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== '') {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== '') {\n            if (allowIndexed && node.name === 'indexed') {\n              node.indexed = true;\n              node.name = '';\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case ']':\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n\n  delete parent.state;\n\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n} // @TODO: Better return type\n\n\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n\n      case '':\n        break;\n\n      default:\n        errors.info('unknown modifier: ' + modifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n\n  return abi;\n}\n\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    gas: null,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null,\n    type: 'function'\n  };\n  var comps = fragment.split('@');\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      throw new Error('invalid signature');\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      throw new Error('invalid signature gas');\n    }\n\n    abi.gas = bignumber_1.bigNumberify(comps[1]);\n    fragment = comps[0];\n  }\n\n  comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n\n  abi.name = left[1].trim();\n\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n\n      case 'payable':\n        abi.payable = true;\n        abi.stateMutability = 'payable';\n        break;\n\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n\n      case 'external':\n      case 'public':\n      case '':\n        break;\n\n      default:\n        errors.info('unknown modifier: ' + modifier);\n    }\n  }); // We have outputs\n\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n\n    if (right[1].trim() != '' || right[3].trim() != '') {\n      throw new Error('unexpected tokens');\n    }\n\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  if (abi.name === 'constructor') {\n    abi.type = \"constructor\";\n\n    if (abi.outputs.length) {\n      throw new Error('constructor may not have outputs');\n    }\n\n    delete abi.name;\n    delete abi.outputs;\n  }\n\n  return abi;\n}\n\nfunction parseParamType(type) {\n  return parseParam(type, true);\n}\n\nexports.parseParamType = parseParamType; // @TODO: Allow a second boolean to expose names\n\nfunction formatParamType(paramType) {\n  return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\n\nexports.formatParamType = formatParamType; // @TODO: Allow a second boolean to expose names and modifiers\n\nfunction formatSignature(fragment) {\n  return fragment.name + '(' + fragment.inputs.map(function (i) {\n    return formatParamType(i);\n  }).join(',') + ')';\n}\n\nexports.formatSignature = formatSignature;\n\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\s/g, ' ');\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw new Error('unknown signature');\n}\n\nexports.parseSignature = parseSignature;\n\nvar Coder =\n/** @class */\nfunction () {\n  function Coder(coerceFunc, name, type, localName, dynamic) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  return Coder;\n}(); // Clones the functionality of an existing Coder, but without a localName\n\n\nvar CoderAnonymous =\n/** @class */\nfunction (_super) {\n  __extends(CoderAnonymous, _super);\n\n  function CoderAnonymous(coder) {\n    var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n\n    properties_1.defineReadOnly(_this, 'coder', coder);\n    return _this;\n  }\n\n  CoderAnonymous.prototype.encode = function (value) {\n    return this.coder.encode(value);\n  };\n\n  CoderAnonymous.prototype.decode = function (data, offset) {\n    return this.coder.decode(data, offset);\n  };\n\n  return CoderAnonymous;\n}(Coder);\n\nvar CoderNull =\n/** @class */\nfunction (_super) {\n  __extends(CoderNull, _super);\n\n  function CoderNull(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n  }\n\n  CoderNull.prototype.encode = function (value) {\n    return bytes_1.arrayify([]);\n  };\n\n  CoderNull.prototype.decode = function (data, offset) {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined)\n    };\n  };\n\n  return CoderNull;\n}(Coder);\n\nvar CoderNumber =\n/** @class */\nfunction (_super) {\n  __extends(CoderNumber, _super);\n\n  function CoderNumber(coerceFunc, size, signed, localName) {\n    var _this = this;\n\n    var name = (signed ? 'int' : 'uint') + size * 8;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n\n  CoderNumber.prototype.encode = function (value) {\n    try {\n      var v = bignumber_1.bigNumberify(value);\n\n      if (this.signed) {\n        var bounds = constants_1.MaxUint256.maskn(this.size * 8 - 1);\n\n        if (v.gt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n\n        bounds = bounds.add(constants_1.One).mul(constants_1.NegativeOne);\n\n        if (v.lt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n      } else if (v.lt(constants_1.Zero) || v.gt(constants_1.MaxUint256.maskn(this.size * 8))) {\n        throw new Error('out-of-bounds');\n      }\n\n      v = v.toTwos(this.size * 8).maskn(this.size * 8);\n\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n\n      return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n    } catch (error) {\n      errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: value\n      });\n    }\n\n    return null;\n  };\n\n  CoderNumber.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    var junkLength = 32 - this.size;\n    var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value)\n    };\n  };\n\n  return CoderNumber;\n}(Coder);\n\nvar uint256Coder = new CoderNumber(function (type, value) {\n  return value;\n}, 32, false, 'none');\n\nvar CoderBoolean =\n/** @class */\nfunction (_super) {\n  __extends(CoderBoolean, _super);\n\n  function CoderBoolean(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n  }\n\n  CoderBoolean.prototype.encode = function (value) {\n    return uint256Coder.encode(!!value ? 1 : 0);\n  };\n\n  CoderBoolean.prototype.decode = function (data, offset) {\n    try {\n      var result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value\n        });\n      }\n\n      throw error;\n    }\n\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero())\n    };\n  };\n\n  return CoderBoolean;\n}(Coder);\n\nvar CoderFixedBytes =\n/** @class */\nfunction (_super) {\n  __extends(CoderFixedBytes, _super);\n\n  function CoderFixedBytes(coerceFunc, length, localName) {\n    var _this = this;\n\n    var name = 'bytes' + length;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderFixedBytes.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      var data = bytes_1.arrayify(value);\n\n      if (data.length !== this.length) {\n        throw new Error('incorrect data length');\n      }\n\n      result.set(data);\n    } catch (error) {\n      errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value\n      });\n    }\n\n    return result;\n  };\n\n  CoderFixedBytes.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n    };\n  };\n\n  return CoderFixedBytes;\n}(Coder);\n\nvar CoderAddress =\n/** @class */\nfunction (_super) {\n  __extends(CoderAddress, _super);\n\n  function CoderAddress(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n  }\n\n  CoderAddress.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n    } catch (error) {\n      errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: value\n      });\n    }\n\n    return result;\n  };\n\n  CoderAddress.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for address type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n    };\n  };\n\n  return CoderAddress;\n}(Coder);\n\nfunction _encodeDynamicBytes(value) {\n  var dataLength = 32 * Math.ceil(value.length / 32);\n  var padding = new Uint8Array(dataLength - value.length);\n  return bytes_1.concat([uint256Coder.encode(value.length), value, padding]);\n}\n\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 32) {\n    errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32))\n    });\n  }\n\n  var length = uint256Coder.decode(data, offset).value;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString()\n    });\n  }\n\n  if (data.length < offset + 32 + length) {\n    errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n    });\n  }\n\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length)\n  };\n}\n\nvar CoderDynamicBytes =\n/** @class */\nfunction (_super) {\n  __extends(CoderDynamicBytes, _super);\n\n  function CoderDynamicBytes(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n  }\n\n  CoderDynamicBytes.prototype.encode = function (value) {\n    try {\n      return _encodeDynamicBytes(bytes_1.arrayify(value));\n    } catch (error) {\n      errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value\n      });\n    }\n\n    return null;\n  };\n\n  CoderDynamicBytes.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n\n    result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n    return result;\n  };\n\n  return CoderDynamicBytes;\n}(Coder);\n\nvar CoderString =\n/** @class */\nfunction (_super) {\n  __extends(CoderString, _super);\n\n  function CoderString(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n  }\n\n  CoderString.prototype.encode = function (value) {\n    if (typeof value !== 'string') {\n      errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value: value\n      });\n    }\n\n    return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n  };\n\n  CoderString.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n\n    result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n    return result;\n  };\n\n  return CoderString;\n}(Coder);\n\nfunction alignSize(size) {\n  return 32 * Math.ceil(size / 32);\n}\n\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {// do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues = [];\n    coders.forEach(function (coder) {\n      arrayValues.push(values[coder.localName]);\n    });\n    values = arrayValues;\n  } else {\n    errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  if (coders.length !== values.length) {\n    errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = new Uint8Array(staticSize + dynamicSize);\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      //uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(dynamicOffset), offset);\n      offset += 32; //part.value.copy(data, dynamicOffset);  @TODO\n\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      //part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\n\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber()); // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n    }\n\n    if (result.value != undefined) {\n      value.push(result.value);\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  });\n  return {\n    value: value,\n    consumed: consumed\n  };\n}\n\nvar CoderArray =\n/** @class */\nfunction (_super) {\n  __extends(CoderArray, _super);\n\n  function CoderArray(coerceFunc, coder, length, localName) {\n    var _this = this;\n\n    var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    var dynamic = length === -1 || coder.dynamic;\n    _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n    _this.coder = coder;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderArray.prototype.encode = function (value) {\n    if (!Array.isArray(value)) {\n      errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value: value\n      });\n    }\n\n    var count = this.length;\n    var result = new Uint8Array(0);\n\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(count);\n    }\n\n    errors.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? \" \" + this.localName : \"\"));\n    var coders = [];\n\n    for (var i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n\n    return bytes_1.concat([result, pack(coders, value)]);\n  };\n\n  CoderArray.prototype.decode = function (data, offset) {\n    // @TODO:\n    //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n    var consumed = 0;\n    var count = this.length;\n\n    if (count === -1) {\n      try {\n        var decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value\n        });\n      }\n\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString()\n        });\n      }\n\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n\n    var coders = [];\n\n    for (var i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n\n    var result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderArray;\n}(Coder);\n\nvar CoderTuple =\n/** @class */\nfunction (_super) {\n  __extends(CoderTuple, _super);\n\n  function CoderTuple(coerceFunc, coders, localName) {\n    var _this = this;\n\n    var dynamic = false;\n    var types = [];\n    coders.forEach(function (coder) {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n\n      types.push(coder.type);\n    });\n    var type = 'tuple(' + types.join(',') + ')';\n    _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n    _this.coders = coders;\n    return _this;\n  }\n\n  CoderTuple.prototype.encode = function (value) {\n    return pack(this.coders, value);\n  };\n\n  CoderTuple.prototype.decode = function (data, offset) {\n    var result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderTuple;\n}(Coder);\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\n\n\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = '';\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n} // @TODO: Is there a way to return \"class\"?\n\n\nvar paramTypeSimple = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes\n};\n\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return new CoderTuple(coerceFunc, coders, localName);\n}\n\nfunction getParamCoder(coerceFunc, param) {\n  var coder = paramTypeSimple[param.type];\n\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n\n  var match = param.type.match(paramTypeNumber);\n\n  if (match) {\n    var size = parseInt(match[2] || \"256\");\n\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderNumber(coerceFunc, size / 8, match[1] === 'int', param.name);\n  }\n\n  var match = param.type.match(paramTypeBytes);\n\n  if (match) {\n    var size = parseInt(match[1]);\n\n    if (size === 0 || size > 32) {\n      errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderFixedBytes(coerceFunc, size, param.name);\n  }\n\n  var match = param.type.match(paramTypeArray);\n\n  if (match) {\n    var size = parseInt(match[2] || \"-1\");\n    param = properties_1.shallowCopy(param);\n    param.type = match[1];\n    param = properties_1.deepCopy(param);\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components, param.name);\n  }\n\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name);\n  }\n\n  errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type\n  });\n  return null;\n}\n\nvar AbiCoder =\n/** @class */\nfunction () {\n  function AbiCoder(coerceFunc) {\n    errors.checkNew(this, AbiCoder);\n\n    if (!coerceFunc) {\n      coerceFunc = exports.defaultCoerceFunc;\n    }\n\n    properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n  }\n\n  AbiCoder.prototype.encode = function (types, values) {\n    if (types.length !== values.length) {\n      errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n\n    var coders = [];\n    types.forEach(function (type) {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n      var typeObject = null;\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n  };\n\n  AbiCoder.prototype.decode = function (types, data) {\n    var coders = [];\n    types.forEach(function (type) {\n      // See encode for details\n      var typeObject = null;\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = properties_1.deepCopy(type);\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n  };\n\n  return AbiCoder;\n}();\n\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();","map":{"version":3,"sources":["/home/luc1d/Code/Github/waviii.io/node_modules/ethers/utils/abi-coder.js"],"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","__importStar","mod","__esModule","result","k","call","defineProperty","exports","value","constants_1","require","errors","address_1","bignumber_1","bytes_1","utf8_1","properties_1","paramTypeBytes","RegExp","paramTypeNumber","paramTypeArray","defaultCoerceFunc","type","match","parseInt","toNumber","regexParen","regexIdentifier","verifyType","substring","parseParam","param","allowIndexed","originalParam","throwError","i","Error","replace","parent","name","state","allowType","node","length","c","allowParams","components","indexed","child","allowName","allowArray","sibling","push","readArray","parseSignatureEvent","fragment","abi","anonymous","inputs","trim","splitNesting","forEach","split","modifier","info","parseSignatureFunction","constant","gas","outputs","payable","stateMutability","comps","bigNumberify","left","right","parseParamType","formatParamType","paramType","getParamCoder","formatSignature","map","join","parseSignature","Coder","coerceFunc","localName","dynamic","CoderAnonymous","_super","coder","_this","undefined","defineReadOnly","encode","decode","data","offset","CoderNull","arrayify","consumed","CoderNumber","size","signed","v","bounds","MaxUint256","maskn","gt","add","One","mul","NegativeOne","lt","Zero","toTwos","fromTwos","padZeros","error","INVALID_ARGUMENT","arg","coderType","hexlify","slice","junkLength","uint256Coder","CoderBoolean","reason","isZero","CoderFixedBytes","Uint8Array","set","CoderAddress","getAddress","_encodeDynamicBytes","dataLength","Math","ceil","padding","concat","_decodeDynamicBytes","toString","CoderDynamicBytes","CoderString","toUtf8Bytes","toUtf8String","alignSize","pack","coders","values","isArray","arrayValues","parts","index","staticSize","dynamicSize","part","dynamicOffset","unpack","baseOffset","CoderArray","count","checkArgumentCount","decodedLength","CoderTuple","types","accum","depth","paramTypeSimple","address","bool","string","bytes","getTupleParamCoder","component","shallowCopy","deepCopy","AbiCoder","checkNew","typeObject","defaultAbiCoder"],"mappings":"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","sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nvar constants_1 = require(\"../constants\");\nvar errors = __importStar(require(\"../errors\"));\nvar address_1 = require(\"./address\");\nvar bignumber_1 = require(\"./bignumber\");\nvar bytes_1 = require(\"./bytes\");\nvar utf8_1 = require(\"./utf8\");\nvar properties_1 = require(\"./properties\");\n///////////////////////////////\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexports.defaultCoerceFunc = function (type, value) {\n    var match = type.match(paramTypeNumber);\n    if (match && parseInt(match[2]) <= 48) {\n        return value.toNumber();\n    }\n    return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = 'uint256' + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = 'int256' + type.substring(3);\n    }\n    return type;\n}\nfunction parseParam(param, allowIndexed) {\n    var originalParam = param;\n    function throwError(i) {\n        throw new Error('unexpected character \"' + originalParam[i] + '\" at position ' + i + ' in \"' + originalParam + '\"');\n    }\n    param = param.replace(/\\s/g, ' ');\n    var parent = { type: '', name: '', state: { allowType: true } };\n    var node = parent;\n    for (var i = 0; i < param.length; i++) {\n        var c = param[i];\n        switch (c) {\n            case '(':\n                if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n                node = node.components[0];\n                break;\n            case ')':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case ',':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var sibling = { type: '', name: '', parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case ' ':\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== '') {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== '') {\n                        if (allowIndexed && node.name === 'indexed') {\n                            node.indexed = true;\n                            node.name = '';\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case '[':\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case ']':\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        throw new Error(\"unexpected eof\");\n    }\n    delete parent.state;\n    if (allowIndexed && node.name === 'indexed') {\n        node.indexed = true;\n        node.name = '';\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\n// @TODO: Better return type\nfunction parseSignatureEvent(fragment) {\n    var abi = {\n        anonymous: false,\n        inputs: [],\n        name: '',\n        type: 'event'\n    };\n    var match = fragment.match(regexParen);\n    if (!match) {\n        throw new Error('invalid event: ' + fragment);\n    }\n    abi.name = match[1].trim();\n    splitNesting(match[2]).forEach(function (param) {\n        param = parseParam(param, true);\n        param.indexed = !!param.indexed;\n        abi.inputs.push(param);\n    });\n    match[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'anonymous':\n                abi.anonymous = true;\n                break;\n            case '':\n                break;\n            default:\n                errors.info('unknown modifier: ' + modifier);\n        }\n    });\n    if (abi.name && !abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + abi.name + '\"');\n    }\n    return abi;\n}\nfunction parseSignatureFunction(fragment) {\n    var abi = {\n        constant: false,\n        gas: null,\n        inputs: [],\n        name: '',\n        outputs: [],\n        payable: false,\n        stateMutability: null,\n        type: 'function'\n    };\n    var comps = fragment.split('@');\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            throw new Error('invalid signature');\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            throw new Error('invalid signature gas');\n        }\n        abi.gas = bignumber_1.bigNumberify(comps[1]);\n        fragment = comps[0];\n    }\n    comps = fragment.split(' returns ');\n    var left = comps[0].match(regexParen);\n    if (!left) {\n        throw new Error('invalid signature');\n    }\n    abi.name = left[1].trim();\n    if (!abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + left[1] + '\"');\n    }\n    splitNesting(left[2]).forEach(function (param) {\n        abi.inputs.push(parseParam(param));\n    });\n    left[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'constant':\n                abi.constant = true;\n                break;\n            case 'payable':\n                abi.payable = true;\n                abi.stateMutability = 'payable';\n                break;\n            case 'pure':\n                abi.constant = true;\n                abi.stateMutability = 'pure';\n                break;\n            case 'view':\n                abi.constant = true;\n                abi.stateMutability = 'view';\n                break;\n            case 'external':\n            case 'public':\n            case '':\n                break;\n            default:\n                errors.info('unknown modifier: ' + modifier);\n        }\n    });\n    // We have outputs\n    if (comps.length > 1) {\n        var right = comps[1].match(regexParen);\n        if (right[1].trim() != '' || right[3].trim() != '') {\n            throw new Error('unexpected tokens');\n        }\n        splitNesting(right[2]).forEach(function (param) {\n            abi.outputs.push(parseParam(param));\n        });\n    }\n    if (abi.name === 'constructor') {\n        abi.type = \"constructor\";\n        if (abi.outputs.length) {\n            throw new Error('constructor may not have outputs');\n        }\n        delete abi.name;\n        delete abi.outputs;\n    }\n    return abi;\n}\nfunction parseParamType(type) {\n    return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\nfunction formatParamType(paramType) {\n    return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n// @TODO: Allow a second boolean to expose names and modifiers\nfunction formatSignature(fragment) {\n    return fragment.name + '(' + fragment.inputs.map(function (i) { return formatParamType(i); }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\nfunction parseSignature(fragment) {\n    if (typeof (fragment) === 'string') {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        fragment = fragment.replace(/\\s/g, ' ');\n        fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n        fragment = fragment.trim();\n        if (fragment.substring(0, 6) === 'event ') {\n            return parseSignatureEvent(fragment.substring(6).trim());\n        }\n        else {\n            if (fragment.substring(0, 9) === 'function ') {\n                fragment = fragment.substring(9);\n            }\n            return parseSignatureFunction(fragment.trim());\n        }\n    }\n    throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\nvar Coder = /** @class */ (function () {\n    function Coder(coerceFunc, name, type, localName, dynamic) {\n        this.coerceFunc = coerceFunc;\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    return Coder;\n}());\n// Clones the functionality of an existing Coder, but without a localName\nvar CoderAnonymous = /** @class */ (function (_super) {\n    __extends(CoderAnonymous, _super);\n    function CoderAnonymous(coder) {\n        var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n        properties_1.defineReadOnly(_this, 'coder', coder);\n        return _this;\n    }\n    CoderAnonymous.prototype.encode = function (value) { return this.coder.encode(value); };\n    CoderAnonymous.prototype.decode = function (data, offset) { return this.coder.decode(data, offset); };\n    return CoderAnonymous;\n}(Coder));\nvar CoderNull = /** @class */ (function (_super) {\n    __extends(CoderNull, _super);\n    function CoderNull(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n    }\n    CoderNull.prototype.encode = function (value) {\n        return bytes_1.arrayify([]);\n    };\n    CoderNull.prototype.decode = function (data, offset) {\n        if (offset > data.length) {\n            throw new Error('invalid null');\n        }\n        return {\n            consumed: 0,\n            value: this.coerceFunc('null', undefined)\n        };\n    };\n    return CoderNull;\n}(Coder));\nvar CoderNumber = /** @class */ (function (_super) {\n    __extends(CoderNumber, _super);\n    function CoderNumber(coerceFunc, size, signed, localName) {\n        var _this = this;\n        var name = ((signed ? 'int' : 'uint') + (size * 8));\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.size = size;\n        _this.signed = signed;\n        return _this;\n    }\n    CoderNumber.prototype.encode = function (value) {\n        try {\n            var v = bignumber_1.bigNumberify(value);\n            if (this.signed) {\n                var bounds = constants_1.MaxUint256.maskn(this.size * 8 - 1);\n                if (v.gt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n                bounds = bounds.add(constants_1.One).mul(constants_1.NegativeOne);\n                if (v.lt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n            }\n            else if (v.lt(constants_1.Zero) || v.gt(constants_1.MaxUint256.maskn(this.size * 8))) {\n                throw new Error('out-of-bounds');\n            }\n            v = v.toTwos(this.size * 8).maskn(this.size * 8);\n            if (this.signed) {\n                v = v.fromTwos(this.size * 8).toTwos(256);\n            }\n            return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n        }\n        catch (error) {\n            errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: value\n            });\n        }\n        return null;\n    };\n    CoderNumber.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        var junkLength = 32 - this.size;\n        var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        else {\n            value = value.maskn(this.size * 8);\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, value),\n        };\n    };\n    return CoderNumber;\n}(Coder));\nvar uint256Coder = new CoderNumber(function (type, value) { return value; }, 32, false, 'none');\nvar CoderBoolean = /** @class */ (function (_super) {\n    __extends(CoderBoolean, _super);\n    function CoderBoolean(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n    }\n    CoderBoolean.prototype.encode = function (value) {\n        return uint256Coder.encode(!!value ? 1 : 0);\n    };\n    CoderBoolean.prototype.decode = function (data, offset) {\n        try {\n            var result = uint256Coder.decode(data, offset);\n        }\n        catch (error) {\n            if (error.reason === 'insufficient data for uint256 type') {\n                errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'boolean',\n                    value: error.value\n                });\n            }\n            throw error;\n        }\n        return {\n            consumed: result.consumed,\n            value: this.coerceFunc('bool', !result.value.isZero())\n        };\n    };\n    return CoderBoolean;\n}(Coder));\nvar CoderFixedBytes = /** @class */ (function (_super) {\n    __extends(CoderFixedBytes, _super);\n    function CoderFixedBytes(coerceFunc, length, localName) {\n        var _this = this;\n        var name = ('bytes' + length);\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.length = length;\n        return _this;\n    }\n    CoderFixedBytes.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            var data = bytes_1.arrayify(value);\n            if (data.length !== this.length) {\n                throw new Error('incorrect data length');\n            }\n            result.set(data);\n        }\n        catch (error) {\n            errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: (error.value || value)\n            });\n        }\n        return result;\n    };\n    CoderFixedBytes.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n        };\n    };\n    return CoderFixedBytes;\n}(Coder));\nvar CoderAddress = /** @class */ (function (_super) {\n    __extends(CoderAddress, _super);\n    function CoderAddress(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n    }\n    CoderAddress.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n        }\n        catch (error) {\n            errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: value\n            });\n        }\n        return result;\n    };\n    CoderAddress.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for address type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n        };\n    };\n    return CoderAddress;\n}(Coder));\nfunction _encodeDynamicBytes(value) {\n    var dataLength = 32 * Math.ceil(value.length / 32);\n    var padding = new Uint8Array(dataLength - value.length);\n    return bytes_1.concat([\n        uint256Coder.encode(value.length),\n        value,\n        padding\n    ]);\n}\nfunction _decodeDynamicBytes(data, offset, localName) {\n    if (data.length < offset + 32) {\n        errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32))\n        });\n    }\n    var length = uint256Coder.decode(data, offset).value;\n    try {\n        length = length.toNumber();\n    }\n    catch (error) {\n        errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: length.toString()\n        });\n    }\n    if (data.length < offset + 32 + length) {\n        errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n        });\n    }\n    return {\n        consumed: 32 + 32 * Math.ceil(length / 32),\n        value: data.slice(offset + 32, offset + 32 + length),\n    };\n}\nvar CoderDynamicBytes = /** @class */ (function (_super) {\n    __extends(CoderDynamicBytes, _super);\n    function CoderDynamicBytes(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n    }\n    CoderDynamicBytes.prototype.encode = function (value) {\n        try {\n            return _encodeDynamicBytes(bytes_1.arrayify(value));\n        }\n        catch (error) {\n            errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'bytes',\n                value: error.value\n            });\n        }\n        return null;\n    };\n    CoderDynamicBytes.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n        return result;\n    };\n    return CoderDynamicBytes;\n}(Coder));\nvar CoderString = /** @class */ (function (_super) {\n    __extends(CoderString, _super);\n    function CoderString(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n    }\n    CoderString.prototype.encode = function (value) {\n        if (typeof (value) !== 'string') {\n            errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'string',\n                value: value\n            });\n        }\n        return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n    };\n    CoderString.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n        return result;\n    };\n    return CoderString;\n}(Coder));\nfunction alignSize(size) {\n    return 32 * Math.ceil(size / 32);\n}\nfunction pack(coders, values) {\n    if (Array.isArray(values)) {\n        // do nothing\n    }\n    else if (values && typeof (values) === 'object') {\n        var arrayValues = [];\n        coders.forEach(function (coder) {\n            arrayValues.push(values[coder.localName]);\n        });\n        values = arrayValues;\n    }\n    else {\n        errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    if (coders.length !== values.length) {\n        errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    var parts = [];\n    coders.forEach(function (coder, index) {\n        parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n    });\n    var staticSize = 0, dynamicSize = 0;\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            staticSize += 32;\n            dynamicSize += alignSize(part.value.length);\n        }\n        else {\n            staticSize += alignSize(part.value.length);\n        }\n    });\n    var offset = 0, dynamicOffset = staticSize;\n    var data = new Uint8Array(staticSize + dynamicSize);\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            //uint256Coder.encode(dynamicOffset).copy(data, offset);\n            data.set(uint256Coder.encode(dynamicOffset), offset);\n            offset += 32;\n            //part.value.copy(data, dynamicOffset);  @TODO\n            data.set(part.value, dynamicOffset);\n            dynamicOffset += alignSize(part.value.length);\n        }\n        else {\n            //part.value.copy(data, offset);  @TODO\n            data.set(part.value, offset);\n            offset += alignSize(part.value.length);\n        }\n    });\n    return data;\n}\nfunction unpack(coders, data, offset) {\n    var baseOffset = offset;\n    var consumed = 0;\n    var value = [];\n    coders.forEach(function (coder) {\n        if (coder.dynamic) {\n            var dynamicOffset = uint256Coder.decode(data, offset);\n            var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n            // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n            result.consumed = dynamicOffset.consumed;\n        }\n        else {\n            var result = coder.decode(data, offset);\n        }\n        if (result.value != undefined) {\n            value.push(result.value);\n        }\n        offset += result.consumed;\n        consumed += result.consumed;\n    });\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name) {\n            return;\n        }\n        if (name === 'length') {\n            name = '_length';\n        }\n        if (value[name] != null) {\n            return;\n        }\n        value[name] = value[index];\n    });\n    return {\n        value: value,\n        consumed: consumed\n    };\n}\nvar CoderArray = /** @class */ (function (_super) {\n    __extends(CoderArray, _super);\n    function CoderArray(coerceFunc, coder, length, localName) {\n        var _this = this;\n        var type = (coder.type + '[' + (length >= 0 ? length : '') + ']');\n        var dynamic = (length === -1 || coder.dynamic);\n        _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    CoderArray.prototype.encode = function (value) {\n        if (!Array.isArray(value)) {\n            errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'array',\n                value: value\n            });\n        }\n        var count = this.length;\n        var result = new Uint8Array(0);\n        if (count === -1) {\n            count = value.length;\n            result = uint256Coder.encode(count);\n        }\n        errors.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? (\" \" + this.localName) : \"\"));\n        var coders = [];\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return bytes_1.concat([result, pack(coders, value)]);\n    };\n    CoderArray.prototype.decode = function (data, offset) {\n        // @TODO:\n        //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n        var consumed = 0;\n        var count = this.length;\n        if (count === -1) {\n            try {\n                var decodedLength = uint256Coder.decode(data, offset);\n            }\n            catch (error) {\n                errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: error.value\n                });\n            }\n            try {\n                count = decodedLength.value.toNumber();\n            }\n            catch (error) {\n                errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: decodedLength.value.toString()\n                });\n            }\n            consumed += decodedLength.consumed;\n            offset += decodedLength.consumed;\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new CoderAnonymous(this.coder));\n        }\n        var result = unpack(coders, data, offset);\n        result.consumed += consumed;\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderArray;\n}(Coder));\nvar CoderTuple = /** @class */ (function (_super) {\n    __extends(CoderTuple, _super);\n    function CoderTuple(coerceFunc, coders, localName) {\n        var _this = this;\n        var dynamic = false;\n        var types = [];\n        coders.forEach(function (coder) {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        var type = ('tuple(' + types.join(',') + ')');\n        _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n        _this.coders = coders;\n        return _this;\n    }\n    CoderTuple.prototype.encode = function (value) {\n        return pack(this.coders, value);\n    };\n    CoderTuple.prototype.decode = function (data, offset) {\n        var result = unpack(this.coders, data, offset);\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderTuple;\n}(Coder));\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\nfunction splitNesting(value) {\n    value = value.trim();\n    var result = [];\n    var accum = '';\n    var depth = 0;\n    for (var offset = 0; offset < value.length; offset++) {\n        var c = value[offset];\n        if (c === ',' && depth === 0) {\n            result.push(accum);\n            accum = '';\n        }\n        else {\n            accum += c;\n            if (c === '(') {\n                depth++;\n            }\n            else if (c === ')') {\n                depth--;\n                if (depth === -1) {\n                    throw new Error('unbalanced parenthsis');\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n// @TODO: Is there a way to return \"class\"?\nvar paramTypeSimple = {\n    address: CoderAddress,\n    bool: CoderBoolean,\n    string: CoderString,\n    bytes: CoderDynamicBytes,\n};\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n    if (!components) {\n        components = [];\n    }\n    var coders = [];\n    components.forEach(function (component) {\n        coders.push(getParamCoder(coerceFunc, component));\n    });\n    return new CoderTuple(coerceFunc, coders, localName);\n}\nfunction getParamCoder(coerceFunc, param) {\n    var coder = paramTypeSimple[param.type];\n    if (coder) {\n        return new coder(coerceFunc, param.name);\n    }\n    var match = param.type.match(paramTypeNumber);\n    if (match) {\n        var size = parseInt(match[2] || \"256\");\n        if (size === 0 || size > 256 || (size % 8) !== 0) {\n            errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderNumber(coerceFunc, size / 8, (match[1] === 'int'), param.name);\n    }\n    var match = param.type.match(paramTypeBytes);\n    if (match) {\n        var size = parseInt(match[1]);\n        if (size === 0 || size > 32) {\n            errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderFixedBytes(coerceFunc, size, param.name);\n    }\n    var match = param.type.match(paramTypeArray);\n    if (match) {\n        var size = parseInt(match[2] || \"-1\");\n        param = properties_1.shallowCopy(param);\n        param.type = match[1];\n        param = properties_1.deepCopy(param);\n        return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n    }\n    if (param.type.substring(0, 5) === 'tuple') {\n        return getTupleParamCoder(coerceFunc, param.components, param.name);\n    }\n    if (param.type === '') {\n        return new CoderNull(coerceFunc, param.name);\n    }\n    errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n        arg: 'type',\n        value: param.type\n    });\n    return null;\n}\nvar AbiCoder = /** @class */ (function () {\n    function AbiCoder(coerceFunc) {\n        errors.checkNew(this, AbiCoder);\n        if (!coerceFunc) {\n            coerceFunc = exports.defaultCoerceFunc;\n        }\n        properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n    }\n    AbiCoder.prototype.encode = function (types, values) {\n        if (types.length !== values.length) {\n            errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        var coders = [];\n        types.forEach(function (type) {\n            // Convert types to type objects\n            //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n            //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = type;\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n    };\n    AbiCoder.prototype.decode = function (types, data) {\n        var coders = [];\n        types.forEach(function (type) {\n            // See encode for details\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = properties_1.deepCopy(type);\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n    };\n    return AbiCoder;\n}());\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();\n"]},"metadata":{},"sourceType":"script"}